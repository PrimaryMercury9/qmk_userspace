#include QMK_KEYBOARD_H
#include <stdio.h>
#include "quantum.h"
#include "os_detection.h"
#include "private_macros.h"
#include "work_macros.h"

__attribute__((weak))
bool process_record_keymap(uint16_t keycode, keyrecord_t *record) { return true; }

__attribute__((weak))
bool process_record_secrets(uint16_t keycode, keyrecord_t *record) { return true; }

bool is_alt_tab_active = false;
uint16_t alt_tab_timer = 0;

/*#############################################################################
                            Jiggler stuff
#############################################################################*/
bool is_jiggling = false;

void toggle_jiggler(void) {
    is_jiggling = !is_jiggling; /*flip boolean to true*/
}

/* Random number generator */
static uint32_t prng_seed;

void init_prng(void) {
    prng_seed = timer_read32();
}

uint32_t qmk_rand(void) {
    prng_seed = (prng_seed * 1103515245U + 12345U) % 0xFFFFFFFFU;
    return prng_seed;
}

uint32_t random_mouse_interval(void) {
    // Get a random number between 0 and 30000
    uint32_t interval_ms = qmk_rand() % 30001;
    // Shift to 5000 - 35000
    return interval_ms + 5000;
}
/*#############################################################################
                             Define Macros           
#############################################################################*/
enum local_keycodes {
    CC_JIGG = LOCAL_SAFE_RANGE,
    CC_NUM,
    CC_ATAB
};
/*#############################################################################
                             Aliases           
#############################################################################*/
#define CC_NUM     TO(_NUMPAD)
#define CC_BASE    TO(_BASE)
/*#############################################################################
                             Define Combos           
#############################################################################*/
enum combos {
  CO_ANS,
  CO_ATAB,
  CO_SET
};
/*#############################################################################
                            Define Tap Dance           
#############################################################################*/
enum td_keycodes{
    TD_LYR0
};
/*#############################################################################
                       Define keymap layer names
#############################################################################*/
enum layers {
    _BASE,
    _NUMPAD,
};
/*#############################################################################
                                Layers
#############################################################################*/
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT(
//                |--------|--------|--------|--------|
                    CC_NUM, PM_ACON, PM_LOGS, CC_JIGG,
//                |--------|--------|--------|--------|
                   _______, MA_CLOF, MA_OFR , _______,
//                |--------|--------|--------|--------|
                    CC_DT1,  CC_DT2, CC_DT3 ,  CC_DT4,
//       |--------|--------|--------|--------|--------|
          KC_MUTE, CC_TMUT, CC_TSHR, CC_TCAM, CC_TEND
//       |--------|--------|--------|--------|--------|
    ),

    [_NUMPAD] = LAYOUT(
//                |--------|--------|--------|--------|
                     KC_7,    KC_8,    KC_9,  KC_BSPC,
//                |--------|--------|--------|--------|
                     KC_4,    KC_5,    KC_6,  CC_BASE,
//                |--------|--------|--------|--------|
                     KC_1,    KC_2,    KC_3,  _______,
//       |--------|--------|--------|--------|--------|
          KC_MUTE, _______,   KC_0,   KC_DOT, KC_ENTER
//       |--------|--------|--------|--------|--------|
    ),
};
//#############################################################################
//                               Jiggler
//#############################################################################
/*timers*/
uint32_t idle_timeout = 30000; // (start after 30s inactivity)
//uint32_t mouse_interval = 10000; // (jiggle every 10s)
static uint32_t mouse_interval; // (jiggle every *random* milliseconds)

static uint32_t idle_callback(uint32_t trigger_time, void* cb_arg) {
    // now idle
    if(is_jiggling) {
        tap_code(KC_MS_UP);
        tap_code(KC_MS_DOWN);
        tap_code(KC_MS_LEFT);
        tap_code(KC_MS_RIGHT);
    }
    mouse_interval = random_mouse_interval();
    return mouse_interval;
}
//#############################################################################
//                               Combos
//#############################################################################
#ifdef COMBO_ENABLE
const uint16_t PROGMEM ans_combo[] = {CC_TCAM, CC_TEND, COMBO_END};
const uint16_t PROGMEM atab_combo[] = {CC_TMUT, CC_TSHR, COMBO_END};
const uint16_t PROGMEM setup_combo[] = {PM_ACON, PM_LOGS, COMBO_END};

combo_t key_combos[] = {
  [CO_ANS] = COMBO(ans_combo, CC_ANS),
  [CO_ATAB] = COMBO(atab_combo, CC_ATAB),
  [CO_SET] = COMBO(setup_combo, CC_SET),
};
#endif
//#############################################################################
//                          Custom Tap Dance Functions
// This isn't used at the moment in this map, leaving it as an easy reference
//#############################################################################
#ifdef TAP_DANCE_ENABLE
void layers_select_0(tap_dance_state_t *state, void *user_data) {
    if (state->count >= 1) {
        layer_move(_BASE);
        reset_tap_dance(state);
    }
}
//#############################################################################
//                             Register Tap Dance           
//#############################################################################
tap_dance_action_t tap_dance_actions[] = {
    // Layer selectors
    [TD_LYR0] = ACTION_TAP_DANCE_FN(layers_select_0),
};
#endif
//#############################################################################
//                             Encoders
//#############################################################################
#ifdef ENCODER_ENABLE
bool encoder_update_kb(uint8_t index, bool clockwise) {
    if (IS_LAYER_ON(_BASE)) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    }

    if (IS_LAYER_ON(_NUMPAD)) {
        if (clockwise) {
            tap_code(MS_WHLD);
        } else {
            tap_code(MS_WHLU);
        }
    }
    return false;
}
#endif
/*#############################################################################
                              Set Macros           
#############################################################################*/
bool process_local_macros(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {

        case CC_JIGG:
            if (record->event.pressed) {
                toggle_jiggler();
            }
        break;

        case CC_ATAB:
            if (record->event.pressed) {
                if (!is_alt_tab_active) {
                    is_alt_tab_active = true;
                    register_code(KC_LALT);
                }
                alt_tab_timer = timer_read();
                register_code(KC_TAB);
            } else {
                unregister_code(KC_TAB);
            }
            return false;

    }
    return true;
};
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    // on every key event start or extend `idle_callback()` deferred execution after IDLE_TIMEOUT_MS
    // this is used as the timer to trigger the jiggler after a period of inactivity on the keyboard
    static deferred_token idle_token = INVALID_DEFERRED_TOKEN;
        if (!extend_deferred_exec(idle_token, idle_timeout)) {
            idle_token = defer_exec(idle_timeout, idle_callback, NULL);
    }
    if (!process_private_macros(keycode, record)) return false;
    if (!process_work_macros(keycode, record)) return false;
    if (!process_local_macros(keycode, record)) return false;

    return true;
};
/*#############################################################################
                                 OLED           
#############################################################################*/
#if defined(OLED_ENABLE)
oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    return OLED_ROTATION_270;
}

static const char PROGMEM jiggler_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xbe, 0xbf, 0xbf, 0xbf, 
    0x9e, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0xf8, 0x7e, 0x1f, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xef, 0x1e, 0xbc, 0x30, 0x30, 0x70, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x06, 0x07, 0x03, 0x01, 0x01, 0x80, 0xe0, 0xf8, 0xff, 0x7f, 0x1f, 0x07, 
    0x07, 0x07, 0x1f, 0x7f, 0xfc, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0xff, 0x3f, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x7f, 0xff, 0xff, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const char PROGMEM clear_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

static const char PROGMEM linux_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xde, 0xff, 0xff, 
    0x8f, 0xcf, 0x9e, 0xfe, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x18, 0x07, 0x04, 0x00, 0x04, 
    0x04, 0x02, 0x03, 0x07, 0x1f, 0xfe, 0xf8, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x78, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x10, 0x2f, 0x21, 0x21, 0x00, 0x40, 0x40, 0x01, 0x87, 0xcf, 0x72, 0x60, 0x20, 0x20, 
    0x30, 0x30, 0x30, 0x78, 0x7c, 0xcf, 0x80, 0x81, 0x41, 0x21, 0x30, 0x12, 0x0c, 0x00, 0x00, 0x00, 
};

static const char PROGMEM win_logo[] = {
    0xe0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 
    0xf8, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xfe, 
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 
    0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 
    0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 
    0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x00, 0x00, 
    0x1f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 
};

static const char PROGMEM macos_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0x78, 0x7c, 0x3e, 0x1f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 
    0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x0e, 0x04, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 
    0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00
};

static const char PROGMEM error_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0x78, 0x1c, 0x0c, 0x0e, 
    0x0e, 0x0c, 0x1c, 0x78, 0xf0, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0x3e, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x78, 0xfc, 
    0xfc, 0x38, 0x00, 0x00, 0x01, 0x03, 0x0f, 0x3e, 0xfc, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0xe0, 0xf8, 0x7e, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xdf, 
    0xdf, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1f, 0x3e, 0xf8, 0xe0, 0x80, 
    0x07, 0x1f, 0x3f, 0x38, 0x30, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x71, 
    0x71, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x30, 0x38, 0x3f, 0x1f, 0x07, 
};

static const char PROGMEM numpad_logo[] = {
    0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 
    0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 
    0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 
    0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 
    0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 
    0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
    0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 
    0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 
};

static const char PROGMEM base_logo[] = {
    0x00, 0x00, 0x80, 0x80, 0xc0, 0x40, 0x60, 0x20, 0x30, 0x18, 0x08, 0x0c, 0x04, 0x06, 0x03, 0x03, 
    0x03, 0x03, 0x06, 0x04, 0x0c, 0x08, 0x18, 0x30, 0x20, 0x60, 0x40, 0xc0, 0x80, 0x80, 0x00, 0x00, 
    0x86, 0xcf, 0x79, 0x31, 0x30, 0x60, 0x40, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0x40, 0x60, 0x30, 0x31, 0x79, 0xcf, 0x86, 
    0x61, 0xf3, 0x9e, 0x8c, 0x0c, 0x08, 0x18, 0x30, 0x20, 0x61, 0x43, 0xc2, 0x86, 0x84, 0x0c, 0x08, 
    0x08, 0x0c, 0x84, 0x86, 0xc3, 0x43, 0x61, 0x20, 0x30, 0x18, 0x08, 0x0c, 0x8c, 0x9e, 0xf3, 0x61, 
    0x00, 0x00, 0x01, 0x01, 0x03, 0x02, 0x06, 0x04, 0x0c, 0x18, 0x10, 0x30, 0x21, 0x61, 0xc3, 0xc2, 
    0xc2, 0xc3, 0x61, 0x21, 0x30, 0x10, 0x18, 0x0c, 0x04, 0x06, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 
};

static void render_os_logo(void) {
    switch (detected_host_os()) {
        case OS_IOS:
        case OS_MACOS:
            oled_write_raw_P(macos_logo, sizeof(macos_logo));
            break;
        case OS_LINUX:
            oled_write_raw_P(linux_logo, sizeof(linux_logo));
            break;
        case OS_WINDOWS:
            oled_write_raw_P(win_logo, sizeof(win_logo));
            break;
        default:
            oled_write_raw_P(error_logo, sizeof(error_logo));
            break;
    };
}

static void render_layer(void) {
    switch (get_highest_layer(layer_state)) {
        case _BASE:
            oled_write_raw_P(base_logo, sizeof(base_logo));
            //The following will show OS symbol instead of layer symbol, this can be used on Kyria maybe to reduce number of symbols?
            //switch (detected_host_os()) {
            //    case OS_LINUX:
            //        oled_write_raw_P(linux_logo, sizeof(linux_logo));
            //        break;
            //    default:
            //        oled_write_raw_P(error_logo, sizeof(error_logo));
            //        break;
            //};
            break;
        case _NUMPAD:
            oled_write_raw_P(numpad_logo, sizeof(numpad_logo));
            break;
        default:
            oled_write_raw_P(error_logo, sizeof(error_logo));
            break;
    }
}

void render_jiggling(void) {
    if(is_jiggling) {
        oled_write_raw_P(jiggler_logo, sizeof(jiggler_logo));
    } else {
        oled_write_raw_P(clear_logo, sizeof(clear_logo));
    }
}

bool oled_task_user(void) {
    oled_set_cursor(0,0);
    render_layer();
    oled_set_cursor(0,6);
    render_os_logo();
    oled_set_cursor(0,12);
    render_jiggling();

    return true;
}
#endif

void matrix_scan_user(void) {
    //if using alt tab, alt is released after Xms of inactivity
    if (is_alt_tab_active && timer_elapsed(alt_tab_timer) > 1000) {
        unregister_code(KC_LALT);
        is_alt_tab_active = false;
    }
}
